function [cfg,final_offsets,data_proc,meta_proc] = SUNA_calibration_reference_measurements(data_avg, data_proc,meta_proc,cfg)
%FUNCTION SUNA_calibration_reference_measurements
%
%  Syntax:
%    [data_proc,meta_proc,cfg] = SUNA_calibration_reference_measurements(data_proc,meta_proc,cfg)
%
%  Description: 
%    This script was created by the need to understand how the SUNA
%    characteristics change from the pre deployment and post recovery
%    measurements and assume the appropriate protocol was followed (see
%    Notes section below).
%
%
%    CSV files generated by the SUNA operating in continuous mode before
%    the deployment and after recovery ideally have measurements from a
%    zero nitrate concentration solution (DI/MilliQ water) and a standard
%    nitrate concentration solution (concentration varies, make sure to
%    carefully record this in the future!). 
%    These data are useful for two things. 
%    1) Using the spectral data at each wavelength during the
%       zero-concentration measurements to re-process the data, along with
%       T & S, using the TCSS algorithm [Sakamoto et al., 2009].
%       This is usually the same CSV file that was used to generate the
%       .cal file in the SUNA-COM software, but depending how selecting the
%       zero-concentration spectra is done results in a better/worse cal.
%    2) Using the NO3 values reported by the SUNA during the zero- and
%       standard-concentration measurements to calculate a known instrument
%       offset just before deployment, and just after recovery.
%       These offsets can be used to correct the instrument drift/offset,
%       if there are no suitable insitu discrete samples collected.
%       ******** IMPORTANT CONSIDERATIONS FOR USING THESE OFFSETS ******** 
%        - if no T&S data were recorded when the csv file was generated,
%          the NO3 values reported by the SUNA then we cannot perform
%          Sakamoto et al 2009 corrections and the offset is not as
%          precise. I.e. Not exactly comparing apples to apples because
%          comparing the "offset" of zero- and standard-concentration from
%          non-TCSS correced NO3 values from the deck, to those TCSS
%          corrected NO3 values from the deployment.
%          But... maybe this doesn't matter becau
%        - this one mostly applies to pre-deployment csv files. 
%          If NO3 values are reported in the CSV file, it means those
%          values were caluculated using a .cal file. If that .cal file is
%          different than the one used for processing the moored data,
%          again that is not comparing the same data and care must be taken
%          when using the offsets. 
%          
%
%  References:
%     Pellerin, B. A., Bergamaschi, B. A., Downing, B. D., Saraceno, J. F.,
%     Garrett, J. D., and Olsen, L. D. (2013). Optical techniques for the
%     determination of nitrate in environmental waters: Guidelines for
%     instrument selection, operation, deployment, maintenance, quality
%     assurance, and data reporting. U.S. Geological Survey Techniques and
%     Methods 1-D5, 37. doi: 10.3133/t m1D5
%
%  Notes:
%    This script was created by the need to understand how the SUNA
%    characteristics change from the pre deployment and post recovery
%    measurements and assume the following protocol was followed. 
%    ---------------------Deployment protocol------------------------------
%      1) Generate a .cal and .pdf calibration update prior to deployment
%         This involves wrapping the lens space with parafilm and filling
%         it with DI, then follow the instructions through SUNAcom for a
%         calibration update. The SUNA is then placed in continuous by time
%         measuring mode and a minute of readings of DI water are
%         taken.(This goes into the CSV file).
%      2) Nitrate standard is measured
%         The DI water (zero concentration) is removed, the parafilm
%         replaced and the lenspace filled with the nitrate standard from
%    ---------------------Recovery protocol--------------------------------
%      1) The procedure after recovery has been to switch the
%         SUNA from periodic sampling to continuous and log about a minute
%         of the 2 standards (DI and nitrate standard, ~30uM in the past)
%         into the suna's .csv memory.
%
%         Post recovery note from moorning technician Pete: "No new .cal
%         files are generated (If I remember 2015 correctly, we decided not
%         to include an updated cal file after recovery because the
%         instruments cal file is replaced when a new one is generated."
%
% -------------------------------------------------------------------------
%     Absorption temperature dependence
%     The temperature dependence of the sea salt absorbance is illustrated
%     in Figure 2, which is a compilation of 12 experiments. The
%     baseline-corrected seawater absorbances within 217.0–217.3 and
%     224.8–225.2 nm wavelengths range increase at higher sample
%     temperature (Figure 2A), whereas the absorbances of 40 µM NO3
%     standards made up in DIW (five experiments) do not show a temperature
%     dependence (Figure 2B). [Sakamoto et al., 2009]
% -------------------------------------------------------------------------
%     Response from Sea-Bird when asked about creating new .cal file from
%     csv data: 
%       "Per the SUNA user's manual, we recommend that the user
%        perform a DIW reference update on the SUNA periodically, and
%        before each deployment.  This will update the DIW reference
%        columns, but will not affect the other columns in the data file.
%        The only way to update the other calibration reference values is
%        to return the instrument to Sea-bird for a full calibration. Using
%        calibration files with the DIW reference updated will account for
%        the majority of drift experienced by the SUNA.  We still recommend
%        sending the sensor back for annual maintenance and service when
%        possible.
%
%  Authors:
%    Brita K Irving  <bkirving@alaska.edu>

%% 0 | Set up script
if isfield(cfg,'save_figures')
  savefig = cfg.save_figures;
else
  savefig = false;
end
% Define filenames to save pre and/or post deployment reference measurement
% data to
calpost_file = fullfile(cfg.datadir,[cfg.project '_post_deployment_reference_caldata.mat']);
calpre_file  = fullfile(cfg.datadir,[cfg.project '_pre_deployment_reference_caldata.mat']);

%% 2 | Read pre-deployment SUNA reference data
% Usually, SUNA data is collected on deck before the mooring is deployed.
% These measurements are usually taken during/before the .cal file is
% stored on the SUNA and used for that deployment. However, using the
% actual CSV file, as is done here, gives us a more hands-on way to verify
% these measurements are accurate and allow us to correct for
% pre-deployment offsets. 
% All information about the pre-deployment, and post-deployment calibration
% and measurements are configured in the SUNA_config.m script.
if isfield(cfg.SUNA.cal,'precal') && ~isequal(cfg.SUNA.cal.precal,0)
  files = [];
  for nfile = 1:numel(cfg.SUNA.cal.precal.files)
    if strcmp(cfg.project,'CEO_2016')
      files = [files; fullfile(cfg.datadir,'CAL','deployment',cfg.SUNA.cal.precal.files{nfile})];
    else
      files = [files; fullfile(cfg.datadir,'CAL',cfg.SUNA.cal.precal.files{nfile})];
    end
  end
  % READ IN PRE-DEPLOYMENT REFERENCE MEASUREMENTS
  try
    [~,predeploy,~] = SUNA_read_data(cfg,files);
  catch
    keyboard
  end
  % Ignore dark counts
  predeploy(predeploy.dark == 0,:) = [];
  
  fields = fieldnames(predeploy);
  spec_fields = contains(fields,'spec') & ~contains(fields,{'spec_temp' 'spec_avg'});
  spectrum_channels = table2array(predeploy(:,spec_fields));
  % convert to table
  predeploy(:,spec_fields) = [];
  predeploy = table2struct(predeploy,'ToScalar',true);
  predeploy.spectrum_channels = spectrum_channels;
 
  %fprintf('make sure cal file is the same!\n')
  %keyboard
  if isnan(cfg.SUNA.cal.precal.NO3_uM)
    % Assume 30 uM because that's what has been used in the past....
    predeploy.NO3_uM_standard = repmat(30,size(predeploy.NO3_uM));
  else
    predeploy.NO3_uM_standard = repmat(cfg.SUNA.cal.precal.NO3_uM,size(predeploy.NO3_uM));
  end
  
  %% (IF POSSIBLE) CALCULATE TCSS CORRECTED NITRATE
  if isempty(cfg.SUNA.cal.precal.ctd_file) && all(isnan(predeploy.ctd_temp))
    fprintf(' CTD data NOT available during pre-deployment reference measurements\n')
    predeploy.NO3_uM_TCSS      = nan(size(predeploy.NO3_uM));
    predeploy.NO3_uM_TCSS_rmse = nan(size(predeploy.NO3_uM));
  else % CTD DATA IS AVAIABLE!
    if ~isempty(cfg.SUNA.cal.precal.ctd_file)
      predeploy = read_ctd_data(precal,cfg.SUNA.cal.precal.ctd_file);
    elseif ~all(isnan(predeploy.ctd_temp))
      predeploy.pressure    = predeploy.ctd_press;
      predeploy.temperature = predeploy.ctd_temp;
      predeploy.salinity    = predeploy.ctd_sal;
    end
    % Now correct SUNA data with ISUS Processing
    % temperature compensated salinity subtracted
    [NTR,rmse] = ISUS_REPROCESSOR_v2_bi(predeploy,'',cfg.SUNA.cal1.caldata);
    predeploy.NO3_uM_TCSS      = NTR;
    predeploy.NO3_uM_TCSS_rmse = rmse;
  end
else
  % No pre-deployment CSV files are avaiable so no offset can be determined
  predeploy = [];
end

%% 3 | Read post-recovery SUNA reference data
% Usually, SUNA data is collected on deck after the mooring is recovered.
% These measurements can be used to basically create another cal file and
% use it for determining the offset at the end of the deployment. 
% All information about the pre-deployment, and post-deployment calibration
% and measurements are configured in the SUNA_config.m script. 
if isfield(cfg.SUNA.cal,'postcal')
  if ~iscell(cfg.SUNA.cal.postcal.files)
    cfg.SUNA.cal.postcal.files = cellstr(cfg.SUNA.cal.postcal.files);
  end
  files = [];
  for nfile = 1:numel(cfg.SUNA.cal.postcal.files)
    files = [files; fullfile(cfg.datadir,'CAL',cfg.SUNA.cal.postcal.files{nfile})];
  end
  
  % read in data
  [~,postdeploy,~] = SUNA_read_data(cfg,files);
  % Ignore dark counts
  postdeploy(postdeploy.dark == 0,:) = [];
  % Pull out spectrum fields
  fields = fieldnames(postdeploy);
  spec_fields = contains(fields,'spec') & ~contains(fields,{'spec_temp' 'spec_avg'});
  spectrum_channels = table2array(postdeploy(:,spec_fields));
  % convert to table
  postdeploy(:,spec_fields) = [];
  postdeploy = table2struct(postdeploy,'ToScalar',true);
  postdeploy.spectrum_channels = spectrum_channels;
  
  %fprintf('make sure cal file is the same!\n')
  %keyboard
  if isnan(cfg.SUNA.cal.postcal.NO3_uM)
    % Assume 30 uM because that's what has been used in the past....
    postdeploy.NO3_uM_standard = repmat(30,size(postdeploy.NO3_uM));
  else
    postdeploy.NO3_uM_standard = repmat(cfg.SUNA.cal.postcal.NO3_uM,size(postdeploy.NO3_uM));
  end
  
  %% (IF POSSIBLE) CALCULATE TCSS CORRECTED NITRATE
  if isempty(cfg.SUNA.cal.postcal.ctd_file) && all(isnan(postdeploy.ctd_temp))
    fprintf(' CTD data NOT available during post-recovery reference measurements\n')
    postdeploy.NO3_uM_TCSS      = nan(size(postdeploy.NO3_uM));
    postdeploy.NO3_uM_TCSS_rmse = nan(size(postdeploy.NO3_uM));
  else % CTD DATA IS AVAIABLE!
    if ~isempty(cfg.SUNA.cal.postcal.ctd_file)
      % Read ctd file and interpolate pressure, temperature, and salinity
      postdeploy = read_ctd_data(postcal,cfg.SUNA.cal.postcal.ctd_file);
    elseif ~all(isnan(postdeploy.ctd_temp))
      postdeploy.pressure    = postdeploy.ctd_press;
      postdeploy.temperature = postdeploy.ctd_temp;
      postdeploy.salinity    = postdeploy.ctd_sal;
    end
    % Now correct SUNA data with ISUS Processing
    % temperature compensated salinity subtracted
    % Use the original calibration file that the whole moored dataset was
    % processed with. 
    [NTR,rmse] = ISUS_REPROCESSOR_v2_bi(postdeploy,'',cfg.SUNA.cal1.caldata);
    postdeploy.NO3_uM_TCSS      = NTR;
    postdeploy.NO3_uM_TCSS_rmse = rmse;
  end
else
  % No post-deployment CSV files are avaiable so no offset can be determined
  postdeploy = [];
end

%% 4 | Pull out Nitrate concentration during reference measurements
%-------------------------------------------------------------------------
% Measurements are usually taken with de-ionized water or milliQ water, and
% a nitrate standard. This section plots the reference measurements and
% asks the user to select which part of the data represents what.
% i.e. it just plot referece measurements and asks the user to manually
% select data points with measured nitrate
% -------------------------------------------------------------------------
% 1) pre-deployment reference measurements
if ~isempty(predeploy)
  predeploy = select_nitrate_reference_measurements_on_plot(predeploy,'pre-deployment');
end
% 2) post-recovery reference measurements
if ~isempty(postdeploy)
  postdeploy = select_nitrate_reference_measurements_on_plot(postdeploy,'post-recovery');
end

%% 5 | Apply absolute offset and drift corrections (when available)
if ~isempty(predeploy) && ~isempty(postdeploy)
  % BOTH pre-deployment and post-recovery reference measurements available.
  % Calculate and apply absolute offsets at the beginning and end of
  % deployment and use those to calculate and apply drift correction.
  type = 'pre-deployment and post-recovery';
  absolute_offset_and_drift_corrections
elseif ~isempty(predeploy) && isempty(postdeploy)
  % ONLY pre-deployment reference measurements available. Calculate
  % absolute offset at beginning of deployment and apply to whole dataset
  type = 'pre-deployment';
  absolute_offset_correction(predeploy)
elseif isempty(predeploy) && ~isempty(postdeploy)
  % ONLY post-recovery reference measurements available. Calculate absolute
  % offset at end of deployment and apply to whole dataset
  type = 'post-recovery';
  absolute_offset_correction(postdeploy)
else
  fprintf('Neither pre-deployment OR post-recovery reference measurements available!\n')
  final_offsets = [];
  return
end

if ~isvarname('final_offsets')
  final_offsets = [];
end

%% 4 | Write new calibration files with data from reference measurements
% first - need to read in original calibration data because all the columns
% will stay the same, except "Reference".
% Note from Sea-Bird about column values. "If you're seeing multiple
% calibration files where only the reference column changed, that means
% that these were calibrations where a DIW reference update was performed
% by the user.  When a full calibration is performed at Sea-bird, all of
% the columns will be updated."
% -------------------------------------------------------------------------
% Column names are:
%   H          | header string
%   Wavelength | wavelength in micrometer
%   NO3        | the ratio of UV absorbance at each wavelength with the reference nitrate standard specified in the calibration range for each SUNA.
%   SWA        | the absorbance in the seawater standard that we use for our nitrate calibrations.
%   TSWA       | a proprietary coefficient that is used by our internal algorithm.  It's related to the temperature/salinity correction that can be applied in post processing.
%   Reference  | average spectra output at each wavelength while zero-concentration (DI/MilliQ) water was being measured. 
cal_original = cfg.SUNA.cal1.caldata;
% Also need to read in the header so can write the same file...
% build file path
if     exist(fullfile(cfg.datadir,'CAL',cfg.SUNA.cal1.calfile),'file')
   calfile = fullfile(cfg.datadir,'CAL',cfg.SUNA.cal1.calfile);
elseif exist(fullfile(cfg.datadir,'CAL','deployment',cfg.SUNA.cal1.calfile),'file')
   calfile = fullfile(cfg.datadir,'CAL','deployment',cfg.SUNA.cal1.calfile);
else
  fprintf('could not find %s...\n',cfg.SUNA.cal1.calfile)
  keyboard
end
fileID = fopen(calfile,'r'); % Open calibration file to read in header
hdr = {};  % initialize header
cnt = 1;   % update counter so can loop through
str = fgetl(fileID); % initialize header str
while ~strcmp(str(1),'E')
  hdr = [hdr; str];    % add next line to header text
  cnt = cnt + 1;       % update counter
  str = fgetl(fileID); % read next line from file
end
fclose(fileID); % close calibration file

%% 5 | Write new calibration files with data from reference measurements
% Before deployment - i.e. measurements collected on deck with DI/MilliQ
% water and/or nitrate standard. 
if ~isempty(predeploy) && ~isempty(predeploy.baseline_idx)
  % Initialize structure and fill in basic information
  cal_pre = struct();
  cal_pre.csvfile = predeploy.filename(predeploy.baseline_idx(1),:);
  cal_pre.lamphrs = round(nanmean(predeploy.cum_lampon_sec(predeploy.baseline_idx))./60./60);
  cal_pre.lampsec = nanmean(predeploy.cum_lampon_sec(predeploy.baseline_idx));
  
  % initialize calibration data table with original values, then update
  % Reference values.
  cal_pre.caldata  = cal_original;
  cal_pre.caldata.Reference = nanmean(predeploy.spectrum_channels(predeploy.baseline_idx,:),1)';
  
  % Add pertinent information to header so can write new .cal file
  add_text = {['H,File creation time ' datestr(now,'dd-mmm-yyyy HH:MM:SS')];...
    'H,File generated in MATLAB with SUNA_write_cal.m';...
    ['H,Reference data from ' cal_pre.csvfile];...
    ['H,Reference data collected on ' datestr(predeploy.datenum(predeploy.baseline_idx(1)))];...
    ['H,Reference data collected when lampsec ' num2str(cal_pre.lampsec)];...
    ['H,Reference data collected before SUNA was deployed on mooring ' cfg.project];...
    ['H,Columns "Wavelength" "NO3" "SWA" and "TWSA" from ' cfg.SUNA.cal1.calfile]};
  cal_pre.header = [add_text; hdr];
  cal_pre.calfile = strrep(cfg.SUNA.cal1.calfile,'.cal','_predeploy.cal');
  
  % Write new .cal file
  SUNA_write_calfile(cfg,cal_pre)
  
  % Save data in matlab format
  if exist(calpre_file,'file')
    calpre_file = strrep(calpre_file,'.mat',['_' datestr(now,'yyyymmdd') '.mat']);
  end
  save(calpre_file,'cal_pre','predeploy');
end
% After recovery - i.e. measurements collected on deck with DI/MilliQ
% water and/or nitrate standard after moored SUNA was recovered
if ~isempty(postdeploy)
  % Initialize structure and fill in basic information
  cal_post = struct();
  cal_post.csvfile = postdeploy.filename(postdeploy.baseline_idx(1),:);
  cal_post.lamphrs = round(nanmean(postdeploy.cum_lampon_sec(postdeploy.baseline_idx))./60./60);
  cal_post.lampsec = nanmean(postdeploy.cum_lampon_sec(postdeploy.baseline_idx));
  
  % initialize calibration data table with original values, then update
  % Reference values.
  cal_post.caldata  = cal_original;
  cal_post.caldata.Reference = nanmean(postdeploy.spectrum_channels(postdeploy.baseline_idx,:),1)';
  
  % Add pertinent information to header so can write new .cal file
  add_text = {['H,File creation time ' datestr(now,'dd-mmm-yyyy HH:MM:SS')];...
    'H,File generated in MATLAB with SUNA_write_cal.m';...
    ['H,Reference data from ' cal_post.csvfile];...
    ['H,Reference data collected on ' datestr(postdeploy.datenum(postdeploy.baseline_idx(1)))];...
    ['H,Reference data collected when lampsec ' num2str(cal_post.lampsec)];...
    ['H,Reference data collected after SUNA was recovery on mooring ' cfg.project];...
    ['H,Columns "Wavelength" "NO3" "SWA" and "TWSA" from ' cfg.SUNA.cal1.calfile]};
  cal_post.header = [add_text; hdr];
  cal_post.calfile = strrep(cfg.SUNA.cal1.calfile,'.cal','_postrecovery.cal');
  % Write new .cal file
  SUNA_write_calfile(cfg,cal_post);
  
  if exist(calpost_file,'file')
    calpost_file = strrep(calpost_file,'.mat',['_' datestr(now,'yyyymmdd') '.mat']);
  end
  save(calpost_file,'cal_post','postdeploy');
end

%% 5 | Calculate TCSS Nitrate using new calibration files
% Not entirely necessary perhaps.. because really we are more interested in
% the difference in measured values and "true" values in these
% measurements when zero_concentration and standard_concentrations are
% measured. 
if ~isempty(predeploy) && ~isempty(predeploy.baseline_idx)
  %Recalculate data with pre recovery reference measurements
  fprintf('Calculating TCSS Nitrate concentration using pre-deployment reference measurements\n');
  if cfg.SUNA.TCSS_ignore_flag % do not calculate TCSS where data has been flagged
    [NTR_pre,rmse_pre] = ISUS_REPROCESSOR_v2_bi(data_proc,meta_proc,cal_pre.caldata); % pass meta_proc if want to ignore bad data
  else % calculate TCSS for every measurement regardless of flag
    [NTR_pre,rmse_pre] = ISUS_REPROCESSOR_v2_bi(data_proc,[],cal_pre.caldata);        % do NOT pass meta_proc through if want to include bad data
  end
  data_proc.NO3_uM_TCSS_pre      = NTR_pre;
  data_proc.NO3_uM_TCSS_pre_rmse = rmse_pre;
  % update metadata
  meta_proc.NO3_uM_TCSS_pre         = meta_proc.NO3_uM;
  meta_proc.NO3_uM_TCSS_pre.sources = {'NO3_uM' 'dark' 'salinity' 'temperature' 'spectrum_channels'};
  meta_proc.NO3_uM_TCSS_pre.method  = 'ISUS_REPROCESSOR_v2_bi.m';
  meta_proc.NO3_uM_TCSS_pre.refdata = cal_pre;
  meta_proc.NO3_uM_TCSS_pre.calfile = cal_pre.calfile;
  meta_proc.NO3_uM_TCSS_pre.caldata = cal_pre.caldata;
  meta_proc.NO3_uM_TCSS_pre.meaning = 'Sakamoto et al. (2009) Temperature compensated salinity subtracted (TCSS)';
end

if ~isempty(postdeploy)
  %Recalculate data with post recovery reference measurements
  fprintf('Calculating TCSS Nitrate concentration using post-recovery reference measurements\n');
  if cfg.SUNA.TCSS_ignore_flag
    [NTR_post,rmse_post] = ISUS_REPROCESSOR_v2_bi(data_proc,meta_proc,cal_post.caldata); % pass meta_proc if want to ignore bad data
  else
    [NTR_post,rmse_post] = ISUS_REPROCESSOR_v2_bi(data_proc,[],cal_post.caldata);        % do NOT pass meta_proc through if want to include bad data
  end  
  data_proc.NO3_uM_TCSS_post      = NTR_post;
  data_proc.NO3_uM_TCSS_post_rmse = rmse_post;
  % update metadata
  meta_proc.NO3_uM_TCSS_post         = meta_proc.NO3_uM;
  meta_proc.NO3_uM_TCSS_post.sources = {'NO3_uM' 'dark' 'salinity' 'temperature' 'spectrum_channels'};
  meta_proc.NO3_uM_TCSS_post.method  = 'ISUS_REPROCESSOR_v2_bi.m';
  meta_proc.NO3_uM_TCSS_post.refdata = cal_post;
  meta_proc.NO3_uM_TCSS_post.calfile = cal_post.calfile;
  meta_proc.NO3_uM_TCSS_post.caldata = cal_post.caldata;
  meta_proc.NO3_uM_TCSS_post.meaning = 'Sakamoto et al. (2009) Temperature compensated salinity subtracted (TCSS)';
end

%% 6 | Save data
save(cfg.path.calfile_step2,'data_proc','meta_proc','final_offsets');


%% FUNCTION absolute_offset_and_drift_corrections
  function absolute_offset_and_drift_corrections
    %% Calculate the offsets / drift error
    % Ed = Vs - Vc [Pellerin et al., 2013 eq 5]
    %  where Ed = calibration drift error, Vs = known concentration of
    %  nitrate standard or solution, and Vc = nitrate concentration
    %  reported by sensor in the standard or solution
    offset.predeploy.date                      = datestr(nanmean(predeploy.datenum));
    offset.predeploy.cum_lampon_sec            = round(nanmean(predeploy.cum_lampon_sec),2);
    offset.predeploy.baseline_uM_measured      = predeploy.baseline_NO3;
    offset.predeploy.standard_uM_measured      = predeploy.standard_NO3;
    offset.predeploy.baseline_uM_TCSS_measured = predeploy.baseline_NO3_TCSS;
    offset.predeploy.standard_uM_TCSS_measured = predeploy.standard_NO3_TCSS;
    offset.predeploy.baseline_uM_true          = 0;
    offset.predeploy.standard_uM_true          = predeploy.NO3_uM_standard(1);
    
    offset.postdeploy.date                      = datestr(nanmean(postdeploy.datenum));
    offset.postdeploy.cum_lampon_sec            = round(nanmean(postdeploy.cum_lampon_sec),2);
    offset.postdeploy.baseline_uM_measured      = postdeploy.baseline_NO3;
    offset.postdeploy.standard_uM_measured      = postdeploy.standard_NO3;
    offset.postdeploy.baseline_uM_TCSS_measured = postdeploy.baseline_NO3_TCSS;
    offset.postdeploy.standard_uM_TCSS_measured = postdeploy.standard_NO3_TCSS;
    offset.postdeploy.baseline_uM_true          = 0;
    offset.postdeploy.standard_uM_true          = postdeploy.NO3_uM_standard(1);
    
    % store linearity
    % E.g. polyfit([zero_concentration_true standard_concentration_true],[zero_concentration_measured standard_concentration_measured])
    % This is not used so far... but could be in the future if multiple
    % nitrate standards of different concentrations are used. Would need to
    % be updated, of course...
    offset.postdeploy.linearity_fit = polyfit([0 postdeploy.NO3_uM_standard(1)],[postdeploy.baseline_NO3 postdeploy.standard_NO3],1);
    offset.predeploy.linearity_fit  = polyfit([0 predeploy.NO3_uM_standard(1) ],[predeploy.baseline_NO3  predeploy.standard_NO3],1);
    
    %% Store the offset + drift
    %     day_int = data_proc.datenum - data_proc.datenum(1); % increasing days from start
    %     offset_and_drift = offset.predeploy.standard_uM_difference + drift.per_day_standard*day_int;
    %     data_proc.ref_offsets = offset_and_drift;
    meta_proc.ref_offsets = struct();
    meta_proc.ref_offsets.unit = 'uM';
    meta_proc.ref_offsets.offsets = offset;
    meta_proc.ref_offsets.meaning = 'Correction from Nitrate standards absolute offsets and drift calculated using pre-deployment and post-recovery reference measurements';
    
    % Do not return data_proc and meta_proc with corrected data, just
    % return structure containing offsets and/or drift so can calcaulate in
    % SUNA_calibration_offset_drift_correction.m
    final_offsets = meta_proc.ref_offsets;
  end %% FUNCTION absolute_offset_and_drift_corrections

%% FUNCTION absolute_offset_correction
  function absolute_offset_correction(ref_data)
    %% Calculate the offsets / drift error
    % Ed = Vs - Vc [Pellerin et al., 2013 eq 5]
    %  where Ed = calibration drift error, Vs = known concentration of
    %  nitrate standard or solution, and Vc = nitrate concentration
    %  reported by sensor in the standard or solution
    % Baseline masurements
    switch type
      case 'pre-deployment'
        stype = 'predeploy';
      case 'post-recovery'
        stype = 'postdeploy';
      otherwise
        fprintf('%s not recognized...\n',type)
        keyboard
    end
    
    offset.(stype).date                      = datestr(nanmean(ref_data.datenum));
    offset.(stype).cum_lampon_sec            = round(nanmean(ref_data.cum_lampon_sec),2);
    offset.(stype).baseline_uM_measured      = ref_data.baseline_NO3;
    offset.(stype).baseline_uM_TCSS_measured = ref_data.baseline_NO3_TCSS;
    offset.(stype).baseline_uM_true          = 0;
    if isfield(ref_data,'standard_NO3')
      offset.(stype).standard_uM_measured      = ref_data.standard_NO3;
      offset.(stype).standard_uM_TCSS_measured = ref_data.standard_NO3_TCSS;
      offset.(stype).standard_uM_true          = ref_data.NO3_uM_standard(1);
      % store linearity
      offset.(stype).linearity_fit = polyfit([0 ref_data.NO3_uM_standard(1)],[ref_data.baseline_NO3 ref_data.standard_NO3],1);
    end
    
    %% Store the offset
    meta_proc.ref_offsets = struct();
    meta_proc.ref_offsets.unit    = 'uM';
    meta_proc.ref_offsets.offsets = offset;
    meta_proc.ref_offsets.meaning = [num2str(ref_data.NO3_uM_standard(1)) 'uM standard absolute offset calculated using ' type ' reference measurements'];
    
    % Do not return data_proc and meta_proc with corrected data, just
    % return structure containing offsets and/or drift so can calcaulate in
    % SUNA_calibration_offset_drift_correction.m
    final_offsets = meta_proc.ref_offsets;
  end %% FUNCTION absolute_offset_correction

%% FUNCTION select_nitrate_reference_measurements_on_plot
  function data_table = select_nitrate_reference_measurements_on_plot(data_table,str)
    % plot referece measurements and manually select data points with
    % measured nitrate
    makefig; ax = gca; hold(ax,'on'); grid(ax,'on'); ax.YDir = 'Normal';
    plot(1:numel(data_table.NO3_uM),data_table.NO3_uM_standard,'b--','LineWidth',4,'DisplayName',[str ' standard = ' num2str(data_table.NO3_uM_standard(1)) 'uM'])
    
    ufiles = unique(cellstr(data_table.filename));
    if numel(ufiles) > 1
      clrs = lansey(numel(ufiles));
    else
      clrs = [0.62 0.0039 0.259];
    end
    
    % Plot all measured data
    for nf = 1:numel(ufiles)
      idx = find(strcmp(cellstr(data_table.filename),ufiles{nf}));
      plot(idx,data_table.NO3_uM(idx),'o','MarkerFaceColor',clrs(nf,:),'DisplayName',[str ' measurements: ' strrep(ufiles{nf},'_','\_')])
      %plot(1:numel(data_table.NO3_uM),data_table.NO3_uM,'b*','DisplayName',[str ' measurements'])
      if any(isfinite(data_table.NO3_uM_TCSS))
        plot(idx,data_table.NO3_uM_TCSS(idx),'bd','DisplayName',[str ' TCSS [Sakamoto et al. 2009]'])
      end
    end
    
    % Set lower Y axis limit
    if min(data_table.NO3_uM(idx)) > 0
      ax.YLim(1) = 0;
    else
      ax.YLim(1) = min(data_table.NO3_uM(idx)) - 2;
    end
    % Set upper Y axis limit
    if max(data_table.NO3_uM(idx)) > data_table.NO3_uM_standard(1)
      ax.YLim(2) = max(data_table.NO3_uM(idx)) + 2;
    else
      ax.YLim(2) = data_table.NO3_uM_standard(1) + 2;
    end
    % Configure axis
    ax.Title.String = [strrep(cfg.project,'_',' ') ' | ' str ' reference measurements'];
    try % Matlab R2019a on mac doesn't seeem to like legends...
      hl = legend(ax,'show','Location','northwest'); 
      pause(1);
      hl.FontSize = 14;
    catch
      hl = legend(ax,'show','Location','northwest'); 
      hl.FontSize = 14;
    end
    ax.YLabel.String = 'NO_3 [\muM]';
    ax.XLabel.String = 'Measurement index';
    if savefig
      savename = fullfile(cfg.datadir,[cfg.project '_correction_referenemeasurements_' str]);
      standard_printfig_highrespng(savename);
    end
    
    %% Select baseline values
    ht = text(0.1,0.5,{'Draw rectangle on plot BEFORE nitrate standard was being measured';...
                       '     I.E. where MilliQ or DI water was measured'},'Color','r','FontWeight','bold','units','normalized');
    done = 0;
    while ~done
      fprintf(' Select points on %s plot BEFORE nitrate standard was being measured\n',str);
      x = getrect;
      rng = round(x(1)): round(x(1))+round(x(3)) ;
      if max(rng) >numel(data_table.NO3_uM); rng = rng(1):numel(data_table.NO3_uM);end
      %x = ginput(2);
      %rng = round(x(1,1)):round(x(2,1));
      rng(rng < 1) = [];
      try
        rng = rng(data_table.NO3_uM(rng) >= x(2) & data_table.NO3_uM(rng) <= x(2)+x(4));
        rng = rng(data_table.NO3_uM(rng) ~= 0);
        hp = plot(rng,data_table.NO3_uM(rng),'ro','LineWidth',3,'DisplayName','selected baseline measurements');
        
        % Default to yes - reset below if not available
        zero_concentration_available = 1;
        
        fprintf(' Are the red highlighted points correct?\n')
        fprintf('  <0>  NO \n');
        fprintf('  <1>  YES\n');
        fprintf('  <5>  no milliQ/DIW water measurements\n');
        fprintf('  <99> STOP\n');
        chc = input(' Enter choice: ');
        switch chc
          case 0
            done = 0;
          case 1
            done = 1;
          case 5
            done = 1;
            zero_concentration_available = 0;
          case 99
            done = 0;
            keyboard
        end
        delete(hp)
      catch
        done = 0;
      end
    end
    if zero_concentration_available
      data_table.baseline_idx      = rng;
      data_table.baseline_NO3      = round(nanmean(data_table.NO3_uM(rng)),2);
      data_table.baseline_NO3_TCSS = round(nanmean(data_table.NO3_uM_TCSS(rng)),2);
    else
      data_table.baseline_idx      = [];
      data_table.baseline_NO3      = NaN;
      data_table.baseline_NO3_TCSS = NaN;
    end
    delete(ht);
    
    %% Select Standard measurements
    if all(data_table.NO3_uM_standard == 0) % this happend during the 2018-2019 CEO2 recovery
      fprintf('NO nitrate standard measurements were taken\n');
    else
      ht = text(0.1,0.5,'Draw rectangle on plot where Nitrate standard was being measured','Color','r','FontWeight','bold','units','normalized');
      done = 0;
      while ~done
        fprintf(' Draw rectangle on %s plot around Nitrate standard being measured\n',str);
        %x = ginput(2);
        %rng = round(x(1,1)):round(x(2,1));
        x = getrect;%ginput(2);
        rng = round(x(1)):round(x(1)) + round(x(3));
        if rng(1) == 0; rng = rng(2:end); end
        if max(rng) >numel(data_table.NO3_uM); rng = rng(1):numel(data_table.NO3_uM);end
        rng = rng(data_table.NO3_uM(rng) >= x(2) & data_table.NO3_uM(rng) <= x(2)+x(4));
        hp = plot(rng,data_table.NO3_uM(rng),'ro','LineWidth',3,'DisplayName','selected standard measurements');
        
        try

          fprintf(' Are the red highlighted points correct?\n')
          fprintf('  <0>  NO \n');
          fprintf('  <1>  YES\n');
          fprintf('  <99> STOP\n');
          chc = input(' Enter choice: ');
          switch chc
            case 0
              done = 0;
            case 1
              done = 1;
            case 99
              done = 0;
              keyboard
          end
          delete(hp)
        catch
          done = 0;
        end
      end
      data_table.standard_idx      = rng;
      data_table.standard_NO3      = round(nanmean(data_table.NO3_uM(rng)),2);
      data_table.standard_NO3_TCSS = round(nanmean(data_table.NO3_uM_TCSS(rng)),2);
      delete(ht);
    end
  end %% FUNCTION select_nitrate_reference_measurements_on_plot

%% FUNCTION read_ctd_data
  function data_table = read_ctd_data(data_table,ctd_file)
    % CAUTION: This is not really set up yet because no concurrent CTD data
    % has been available for reference measurements used so far... So,
    % still work required to get this part operational. 
    % Add CTD Data
    % Read in CTD data
    try
      ctd = cnv2mat_mooring(ctd_file);
    catch
      fprintf('Trying to read CTD file...\n')
      ctd_opt = detectImportOptions(ctd_file,'FileType','text','CommentStyle', {'*' '#'});
      ctd_opt.CommentStyle = {'*' '#'};
    end
    % Catch timelag then interpolate time
    makefig; ax = gca; hold(ax,'on'); grid(ax,'on'); ax.YDir = 'Normal';
    plot(ax,data_table.datenum,data_table.NO3_uM,'b*','DisplayName','SUNA reference measurements')
    plot(ax,ctd.datenum,ctd.salinity,'kh','DisplayName','CTD measurements')
    fprintf('Does it look like there is a time lag? Salinity increase should coincide with nitrate increase\n');
    time_lag = input('  Enter choice <1/0>: ');
    if time_lag
      fprintf('figure out time lag here\n');
      keyboard
    end
    % Pressure
    data_table.pressure    = interp1(ctd.datenum,ctd.pressure,data_table.datenum);
    % Temperature
    data_table.temperature = interp1(ctd.datenum,ctd.temp,data_table.datenum);
    % Salinity
    if isfield(ctd,'salinity')
      data_table.salinity  = interp1(ctd.datenum,ctd.salinity,data_table.datenum);
    else
      data_table.salinity  = interp1(ctd.datenum,gsw_SP_from_C(ctd.cond*10,ctd.temp,ctd.pressure),data_table.datenum);
    end
  end %% FUNCTION read_ctd_data

end %% MAIN FUNCTION